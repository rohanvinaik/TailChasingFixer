from __future__ import annotations
from typing import Any, Dict, Iterable, List, Optional, Tuple

# ------------------------------
# Null-safe helpers
# ------------------------------
def _as_str(x: Any) -> str:
    """Return a safe string; None -> ''."""
    return x if isinstance(x, str) else ""

def _split_lines(x: Any) -> List[str]:
    """Null-safe splitlines; None -> []."""
    s = _as_str(x)
    return s.splitlines() if s else []

def _as_int(x: Any, default: int = 0) -> int:
    try:
        return int(x)
    except Exception:
        return default

def _nonempty(seq: Optional[Iterable]) -> bool:
    return bool(seq) and any(True for _ in seq)

# ------------------------------
# Schema guards
# ------------------------------
REQUIRED_ISSUE_KEYS = ("kind", "file")

def _valid_issue(issue: Dict[str, Any]) -> bool:
    if not isinstance(issue, dict):
        return False
    for k in REQUIRED_ISSUE_KEYS:
        if not isinstance(issue.get(k), str) or not issue.get(k):
            return False
    # suggestions may be None or list
    sug = issue.get("suggestions")
    if sug is not None and not isinstance(sug, list):
        issue["suggestions"] = []  # normalize
    return True

def _normalize_suggestion(s: Dict[str, Any]) -> Dict[str, Any]:
    """Ensure stringy fields are strings; drop unusable suggestions."""
    if not isinstance(s, dict):
        return {}
    out = dict(s)
    # normalize common fields that we later split or print
    out["title"]       = _as_str(out.get("title"))
    out["original"]    = _as_str(out.get("original"))
    out["replacement"] = _as_str(out.get("replacement"))
    out["explanation"] = _as_str(out.get("explanation"))
    out["apply_mode"]  = _as_str(out.get("apply_mode"))  # e.g., "replace", "insert", ...
    # location info
    out["file"]  = _as_str(out.get("file"))
    out["line"]  = _as_int(out.get("line"), 0)
    out["start"] = _as_int(out.get("start"), 0)
    out["end"]   = _as_int(out.get("end"), 0)
    # a suggestion is usable if we at least have a file and some replacement/original text
    if not out["file"] or (not out["replacement"] and not out["original"]):
        out["__drop__"] = True
    return out

# ------------------------------
# Public API
# ------------------------------
def select_fixable_issues(issues: List[Dict[str, Any]],
                          only_kinds: Optional[List[str]] = None,
                          skip_kinds: Optional[List[str]] = None) -> List[Dict[str, Any]]:
    out: List[Dict[str, Any]] = []
    ok = set(only_kinds or [])
    sk = set(skip_kinds or [])
    for i in issues:
        if not _valid_issue(i):
            continue
        kind = i["kind"]
        if ok and kind not in ok:
            continue
        if kind in sk:
            continue
        # normalize suggestions list
        raw_sugs = i.get("suggestions") or []
        norm_sugs = []
        for s in raw_sugs:
            ns = _normalize_suggestion(s)
            if ns and not ns.get("__drop__"):
                norm_sugs.append(ns)
        i["suggestions"] = norm_sugs
        out.append(i)
    return out

def generate_fix_script_py(issues: List[Dict[str, Any]]) -> str:
    """
    Produce a simple interactive fixer script. This never throws on None.
    """
    # We only embed what we need; suggestions are optional.
    lines: List[str] = []
    lines.append("#!/usr/bin/env python3")
    lines.append("# Auto-generated by TailChasingFixer")
    lines.append("import pathlib, sys")
    lines.append("from dataclasses import dataclass")
    lines.append("")
    lines.append("@dataclass")
    lines.append("class Suggestion:")
    lines.append("    file: str")
    lines.append("    line: int = 0")
    lines.append("    original: str = ''")
    lines.append("    replacement: str = ''")
    lines.append("    title: str = ''")
    lines.append("")
    lines.append("SUGGESTIONS = [")
    for i in issues:
        for s in i.get('suggestions', []):
            lines.append(f"    Suggestion(file={s['file']!r}, line={s['line']}, "
                         f"original={s['original']!r}, replacement={s['replacement']!r}, "
                         f"title={s['title']!r}),")
    lines.append("]")
    lines.append("")
    lines.append("def apply_all():")
    lines.append("    for s in SUGGESTIONS:")
    lines.append("        p = pathlib.Path(s.file)")
    lines.append("        try:")
    lines.append("            txt = p.read_text(encoding='utf-8')")
    lines.append("        except Exception:")
    lines.append("            print(f'[WARN] cannot read {p}'); continue")
    lines.append("        if s.original and s.original in txt:")
    lines.append("            txt = txt.replace(s.original, s.replacement)")
    lines.append("        elif s.replacement and s.line > 0:")
    lines.append("            # naive insertion before line (1-based)")
    lines.append("            parts = txt.splitlines(True)")
    lines.append("            idx = max(0, min(len(parts), s.line-1))")
    lines.append("            parts.insert(idx, s.replacement + ('\\n' if not s.replacement.endswith('\\n') else ''))")
    lines.append("            txt = ''.join(parts)")
    lines.append("        else:")
    lines.append("            print(f'[SKIP] {p}:{s.line} has no actionable text')")
    lines.append("            continue")
    lines.append("        try:")
    lines.append("            p.write_text(txt, encoding='utf-8')")
    lines.append("            print(f'[OK] patched {p}')")
    lines.append("        except Exception as e:")
    lines.append("            print(f'[ERR] write failed {p}: {e}')")
    lines.append("")
    lines.append("if __name__ == '__main__':")
    lines.append("    apply_all()")
    lines.append("")
    return '\n'.join(lines)

def generate_suggestions_md(issues: List[Dict[str, Any]]) -> str:
    """
    Markdown suggestions; null-safe and resilient.
    """
    out: List[str] = []
    out.append("# TailChasingFixer â€” Fix Suggestions")
    out.append("")
    by_file: Dict[str, List[Dict[str, Any]]] = {}
    for i in issues:
        by_file.setdefault(i["file"], []).append(i)
    for path, items in sorted(by_file.items()):
        out.append(f"## {path}")
        out.append("")
        for i in items:
            title = _as_str(i.get("message")) or i["kind"]
            out.append(f"### {title}")
            out.append(f"- Kind: `{i['kind']}`  ")
            out.append(f"- Location: `{path}`:{_as_int(i.get('line'), 0)}")
            # Render suggestions, if any
            sugs = i.get("suggestions") or []
            if not sugs:
                out.append("_No automated fix available; manual change recommended._")
                out.append("")
                continue
            for s in sugs:
                out.append(f"- **{_as_str(s.get('title')) or 'Suggested change'}**")
                expl = _as_str(s.get('explanation'))
                if expl:
                    out.append(f"  - {expl}")
                orig_lines = _split_lines(s.get('original'))
                repl_lines = _split_lines(s.get('replacement'))
                if orig_lines:
                    out.append("  - Original:")
                    out.append("    ```")
                    out.extend([f"    {ln}" for ln in orig_lines])
                    out.append("    ```")
                if repl_lines:
                    out.append("  - Replacement:")
                    out.append("    ```")
                    out.extend([f"    {ln}" for ln in repl_lines])
                    out.append("    ```")
                out.append("")
        out.append("")
    return "\n".join(out)