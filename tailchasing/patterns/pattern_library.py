"""
Pattern Library - A curated library of common AI-generated code patterns.

This module provides a library of patterns commonly generated by AI assistants,
including detection rules, fix strategies, and prevention guidelines.
"""

import ast
import json
import re
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Set, Tuple

import yaml


class PatternCategory(Enum):
    """Categories of AI-generated patterns."""
    
    BOILERPLATE = "boilerplate"
    VALIDATION = "validation"
    ERROR_HANDLING = "error_handling"
    DATA_TRANSFORMATION = "data_transformation"
    API_ENDPOINTS = "api_endpoints"
    TEST_FIXTURES = "test_fixtures"
    CONFIGURATION = "configuration"
    LOGGING = "logging"
    AUTHENTICATION = "authentication"
    CACHING = "caching"


@dataclass
class PatternSignature:
    """Signature for identifying a pattern."""
    
    ast_structure: Optional[str] = None  # AST pattern
    regex_pattern: Optional[str] = None  # Regex for text matching
    function_name_pattern: Optional[str] = None  # Function name pattern
    import_pattern: Optional[Set[str]] = None  # Required imports
    complexity_range: Optional[Tuple[int, int]] = None  # Complexity bounds
    line_count_range: Optional[Tuple[int, int]] = None  # Line count bounds


@dataclass
class PatternExample:
    """Example of a pattern with code."""
    
    code: str
    language: str = "python"
    description: str = ""
    file_context: str = ""  # Where this typically appears


@dataclass
class FixStrategy:
    """Strategy for fixing a pattern."""
    
    name: str
    description: str
    implementation: str  # Code template for fix
    effort_estimate: str  # 'trivial', 'easy', 'moderate', 'hard'
    risk_level: str  # 'low', 'medium', 'high'
    automated: bool = False


@dataclass
class PatternDefinition:
    """Complete definition of an AI-generated pattern."""
    
    id: str
    name: str
    category: PatternCategory
    description: str
    prevalence: str  # 'very_common', 'common', 'occasional', 'rare'
    
    # Detection
    signatures: List[PatternSignature] = field(default_factory=list)
    detection_function: Optional[Callable] = None
    
    # Examples
    examples: List[PatternExample] = field(default_factory=list)
    
    # Fixes
    fix_strategies: List[FixStrategy] = field(default_factory=list)
    preferred_fix: Optional[str] = None
    
    # Metadata
    ai_models: List[str] = field(default_factory=list)  # Models that generate this
    first_observed: Optional[str] = None
    severity: str = "medium"
    tags: Set[str] = field(default_factory=set)
    
    # Prevention
    prevention_guidelines: List[str] = field(default_factory=list)
    prompt_improvements: List[str] = field(default_factory=list)


class PatternLibrary:
    """
    Library of common AI-generated patterns.
    
    Provides pattern definitions, detection methods, and fix strategies
    for patterns commonly generated by AI coding assistants.
    """
    
    def __init__(self):
        self.patterns: Dict[str, PatternDefinition] = {}
        self._load_builtin_patterns()
    
    def _load_builtin_patterns(self):
        """Load built-in pattern definitions."""
        
        # Pattern 1: dict_for_update
        self.patterns['dict_for_update'] = PatternDefinition(
            id='dict_for_update',
            name='Dictionary Update Helper',
            category=PatternCategory.DATA_TRANSFORMATION,
            description='Function that converts object to dict excluding None values',
            prevalence='very_common',
            signatures=[
                PatternSignature(
                    function_name_pattern=r'dict_for_update|to_update_dict|get_update_dict',
                    line_count_range=(1, 5)
                )
            ],
            examples=[
                PatternExample(
                    code="""def dict_for_update(obj):
    return {k: v for k, v in obj.__dict__.items() if v is not None}""",
                    description="Classic dict comprehension pattern"
                )
            ],
            fix_strategies=[
                FixStrategy(
                    name='extract_to_utils',
                    description='Extract to shared utilities module',
                    implementation="""# In utils/model_helpers.py
def dict_for_update(obj):
    \"\"\"Convert object to dict, excluding None values.\"\"\"
    return {k: v for k, v in obj.__dict__.items() if v is not None}

# In original files
from utils.model_helpers import dict_for_update""",
                    effort_estimate='trivial',
                    risk_level='low',
                    automated=True
                )
            ],
            preferred_fix='extract_to_utils',
            ai_models=['gpt-4', 'claude', 'codex'],
            severity='low',
            tags={'duplication', 'helper', 'api'},
            prevention_guidelines=[
                "Check for existing utility functions before generating",
                "Use consistent naming for common operations",
                "Prefer standard library solutions (e.g., dataclasses.asdict)"
            ]
        )
        
        # Pattern 2: Empty validation function
        self.patterns['empty_validation'] = PatternDefinition(
            id='empty_validation',
            name='Empty Validation Stub',
            category=PatternCategory.VALIDATION,
            description='Validation function that only passes or returns True',
            prevalence='common',
            signatures=[
                PatternSignature(
                    function_name_pattern=r'validate_.*|check_.*|verify_.*',
                    line_count_range=(1, 3)
                )
            ],
            examples=[
                PatternExample(
                    code="""def validate_input(data):
    pass""",
                    description="Empty validation stub"
                ),
                PatternExample(
                    code="""def check_permissions(user):
    return True""",
                    description="Always-true validation"
                )
            ],
            fix_strategies=[
                FixStrategy(
                    name='implement_validation',
                    description='Add actual validation logic',
                    implementation="""def validate_input(data):
    \"\"\"Validate input data.\"\"\"
    if not data:
        raise ValueError("Data cannot be empty")
    
    required_fields = ['id', 'name']
    for field in required_fields:
        if field not in data:
            raise ValueError(f"Missing required field: {field}")
    
    return True""",
                    effort_estimate='moderate',
                    risk_level='medium'
                ),
                FixStrategy(
                    name='use_schema_validation',
                    description='Use schema validation library',
                    implementation="""from pydantic import BaseModel, ValidationError

class InputSchema(BaseModel):
    id: int
    name: str

def validate_input(data):
    try:
        InputSchema(**data)
        return True
    except ValidationError as e:
        raise ValueError(f"Validation failed: {e}")""",
                    effort_estimate='easy',
                    risk_level='low'
                )
            ],
            preferred_fix='use_schema_validation',
            ai_models=['all'],
            severity='high',
            tags={'security', 'validation', 'stub'},
            prevention_guidelines=[
                "Always implement validation logic immediately",
                "Use schema validation libraries (pydantic, marshmallow)",
                "Add TODO comments if validation is deferred"
            ]
        )
        
        # Pattern 3: Try-except-pass
        self.patterns['silent_exception'] = PatternDefinition(
            id='silent_exception',
            name='Silent Exception Handler',
            category=PatternCategory.ERROR_HANDLING,
            description='Try-except block that silently swallows exceptions',
            prevalence='common',
            signatures=[
                PatternSignature(
                    ast_structure='try_except_pass',
                    regex_pattern=r'except.*:\s*pass'
                )
            ],
            examples=[
                PatternExample(
                    code="""try:
    result = risky_operation()
except:
    pass""",
                    description="Bare except with pass"
                )
            ],
            fix_strategies=[
                FixStrategy(
                    name='add_logging',
                    description='Add logging to exception handler',
                    implementation="""import logging

logger = logging.getLogger(__name__)

try:
    result = risky_operation()
except Exception as e:
    logger.error(f"Operation failed: {e}", exc_info=True)
    # Consider re-raising or handling appropriately
    raise""",
                    effort_estimate='easy',
                    risk_level='low',
                    automated=True
                )
            ],
            severity='high',
            tags={'error_handling', 'anti-pattern'},
            prevention_guidelines=[
                "Always log exceptions",
                "Be specific about exception types",
                "Consider if exception should be re-raised"
            ]
        )
        
        # Pattern 4: Circular import fix attempt
        self.patterns['circular_import_hack'] = PatternDefinition(
            id='circular_import_hack',
            name='Circular Import Workaround',
            category=PatternCategory.BOILERPLATE,
            description='Import inside function to avoid circular dependency',
            prevalence='occasional',
            signatures=[
                PatternSignature(
                    regex_pattern=r'def\s+\w+\(.*\):\s*\n\s+from\s+'
                )
            ],
            examples=[
                PatternExample(
                    code="""def get_user_model():
    from models.user import User  # Avoid circular import
    return User""",
                    description="Import inside function"
                )
            ],
            fix_strategies=[
                FixStrategy(
                    name='refactor_dependencies',
                    description='Refactor to eliminate circular dependency',
                    implementation="""# Move shared functionality to separate module
# In models/base.py
class BaseModel:
    # Shared functionality

# In models/user.py
from .base import BaseModel

class User(BaseModel):
    # User-specific implementation""",
                    effort_estimate='moderate',
                    risk_level='medium'
                )
            ],
            severity='medium',
            tags={'architecture', 'imports'},
            prevention_guidelines=[
                "Design clear module hierarchy",
                "Use dependency injection",
                "Keep modules focused on single responsibility"
            ]
        )
        
        # Pattern 5: Repetitive test setup
        self.patterns['test_setup_duplication'] = PatternDefinition(
            id='test_setup_duplication',
            name='Duplicated Test Setup',
            category=PatternCategory.TEST_FIXTURES,
            description='Repeated test setup code across test methods',
            prevalence='very_common',
            signatures=[
                PatternSignature(
                    function_name_pattern=r'test_.*',
                    regex_pattern=r'self\.client\s*=|self\.user\s*='
                )
            ],
            examples=[
                PatternExample(
                    code="""def test_create_user(self):
    self.client = TestClient()
    self.user = User(name="test")
    # test code

def test_update_user(self):
    self.client = TestClient()
    self.user = User(name="test")
    # test code""",
                    description="Repeated setup in each test"
                )
            ],
            fix_strategies=[
                FixStrategy(
                    name='use_setup_method',
                    description='Use setUp method or fixtures',
                    implementation="""class TestUser(TestCase):
    def setUp(self):
        self.client = TestClient()
        self.user = User(name="test")
    
    def test_create_user(self):
        # test code using self.client and self.user
    
    def test_update_user(self):
        # test code using self.client and self.user""",
                    effort_estimate='easy',
                    risk_level='low',
                    automated=True
                )
            ],
            severity='low',
            tags={'testing', 'duplication'},
            prevention_guidelines=[
                "Use test fixtures (pytest) or setUp methods",
                "Create reusable test utilities",
                "Use factory patterns for test data"
            ]
        )
    
    def detect_pattern(self, code: str, ast_tree: Optional[ast.AST] = None) -> List[str]:
        """
        Detect patterns in code.
        
        Args:
            code: Source code string
            ast_tree: Optional parsed AST
            
        Returns:
            List of detected pattern IDs
        """
        detected = []
        
        for pattern_id, pattern in self.patterns.items():
            if self._matches_pattern(code, ast_tree, pattern):
                detected.append(pattern_id)
        
        return detected
    
    def _matches_pattern(self, code: str, ast_tree: Optional[ast.AST], pattern: PatternDefinition) -> bool:
        """Check if code matches a pattern definition."""
        for signature in pattern.signatures:
            # Check regex pattern
            if signature.regex_pattern:
                if re.search(signature.regex_pattern, code):
                    return True
            
            # Check function name pattern
            if signature.function_name_pattern and ast_tree:
                for node in ast.walk(ast_tree):
                    if isinstance(node, ast.FunctionDef):
                        if re.match(signature.function_name_pattern, node.name):
                            # Check line count if specified
                            if signature.line_count_range:
                                line_count = len(node.body)
                                if signature.line_count_range[0] <= line_count <= signature.line_count_range[1]:
                                    return True
                            else:
                                return True
            
            # Check custom detection function
            if pattern.detection_function:
                if pattern.detection_function(code, ast_tree):
                    return True
        
        return False
    
    def get_fix_for_pattern(self, pattern_id: str, strategy_name: Optional[str] = None) -> Optional[FixStrategy]:
        """
        Get fix strategy for a pattern.
        
        Args:
            pattern_id: Pattern identifier
            strategy_name: Specific strategy name (optional)
            
        Returns:
            FixStrategy or None
        """
        pattern = self.patterns.get(pattern_id)
        if not pattern:
            return None
        
        if strategy_name:
            for strategy in pattern.fix_strategies:
                if strategy.name == strategy_name:
                    return strategy
        elif pattern.preferred_fix:
            for strategy in pattern.fix_strategies:
                if strategy.name == pattern.preferred_fix:
                    return strategy
        elif pattern.fix_strategies:
            return pattern.fix_strategies[0]
        
        return None
    
    def get_patterns_by_category(self, category: PatternCategory) -> List[PatternDefinition]:
        """Get all patterns in a category."""
        return [p for p in self.patterns.values() if p.category == category]
    
    def get_patterns_by_severity(self, severity: str) -> List[PatternDefinition]:
        """Get patterns by severity level."""
        return [p for p in self.patterns.values() if p.severity == severity]
    
    def export_patterns(self, file_path: Path, format: str = 'yaml'):
        """Export pattern library to file."""
        patterns_data = {}
        
        for pattern_id, pattern in self.patterns.items():
            patterns_data[pattern_id] = {
                'name': pattern.name,
                'category': pattern.category.value,
                'description': pattern.description,
                'prevalence': pattern.prevalence,
                'severity': pattern.severity,
                'examples': [{'code': ex.code, 'description': ex.description} 
                           for ex in pattern.examples],
                'fix_strategies': [{'name': fs.name, 'description': fs.description}
                                 for fs in pattern.fix_strategies],
                'tags': list(pattern.tags)
            }
        
        with open(file_path, 'w') as f:
            if format == 'yaml':
                yaml.dump(patterns_data, f, default_flow_style=False)
            elif format == 'json':
                json.dump(patterns_data, f, indent=2)
    
    def import_patterns(self, file_path: Path):
        """Import patterns from file."""
        with open(file_path, 'r') as f:
            if file_path.suffix in ['.yaml', '.yml']:
                patterns_data = yaml.safe_load(f)
            else:
                patterns_data = json.load(f)
        
        for pattern_id, data in patterns_data.items():
            # Convert to PatternDefinition
            # (simplified - would need full conversion logic)
            pattern = PatternDefinition(
                id=pattern_id,
                name=data['name'],
                category=PatternCategory(data['category']),
                description=data['description'],
                prevalence=data.get('prevalence', 'common'),
                severity=data.get('severity', 'medium'),
                tags=set(data.get('tags', []))
            )
            self.patterns[pattern_id] = pattern
    
    def generate_prevention_guide(self) -> str:
        """Generate a prevention guide for all patterns."""
        guide = """
AI Code Generation Pattern Prevention Guide
============================================

This guide helps prevent common patterns in AI-generated code that lead to
technical debt and maintenance issues.

"""
        
        for category in PatternCategory:
            patterns = self.get_patterns_by_category(category)
            if patterns:
                guide += f"\n## {category.value.replace('_', ' ').title()}\n\n"
                
                for pattern in patterns:
                    guide += f"### {pattern.name}\n"
                    guide += f"**Prevalence:** {pattern.prevalence}\n"
                    guide += f"**Severity:** {pattern.severity}\n\n"
                    
                    if pattern.prevention_guidelines:
                        guide += "**Prevention:**\n"
                        for guideline in pattern.prevention_guidelines:
                            guide += f"- {guideline}\n"
                        guide += "\n"
                    
                    if pattern.prompt_improvements:
                        guide += "**Better Prompts:**\n"
                        for improvement in pattern.prompt_improvements:
                            guide += f"- {improvement}\n"
                        guide += "\n"
        
        return guide


# Global pattern library instance
_pattern_library: Optional[PatternLibrary] = None


def get_pattern_library() -> PatternLibrary:
    """Get the global pattern library instance."""
    global _pattern_library
    if _pattern_library is None:
        _pattern_library = PatternLibrary()
    return _pattern_library